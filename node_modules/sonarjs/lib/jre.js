"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
* SonarJS-cli
* Copyright (C) 2017-2017 SonarSource SA
* mailto:info AT sonarsource DOT com
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public
* License as published by the Free Software Foundation; either
* version 3 of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program; if not, write to the Free Software Foundation,
* Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/
const os = require("os");
const fs = require("fs");
const path = require("path");
const zlib = require("zlib");
const unzip = require("unzip-stream");
const tar = require("tar-fs");
const request = require("request");
const ProgressBar = require("progress");
const child_process = require("child_process");
const mkdirp = require("mkdirp");
const version = "zulu8.25.0.1-jdk8.0.152-";
function url() {
    return ("http://cdn.azul.com/zulu/bin/" + version + platform() + "_x64" + zip());
}
exports.url = url;
function install(log) {
    return __awaiter(this, void 0, void 0, function* () {
        if (yield isJreAvailable(log)) {
            return Promise.resolve("java");
        }
        if (!fs.existsSync(exports.jreDir())) {
            mkdirp.sync(exports.jreDir());
            const urlStr = url();
            log("Downloading from: " + urlStr, "INFO");
            return new Promise((resolve, reject) => {
                let stream = request
                    .get(buildRequest(urlStr))
                    .on("response", progressBar)
                    .on("error", reportAndCleanup(log));
                if (zip() !== ".zip") {
                    stream
                        .pipe(zlib.createUnzip())
                        .on("error", reportAndCleanup(log))
                        .pipe(tar.extract(exports.jreDir()))
                        .on("finish", () => resolve(driver()));
                }
                else {
                    stream
                        .pipe(unzip.Extract({ path: exports.jreDir() }))
                        .on("error", reportAndCleanup(log))
                        .on("finish", () => resolve(driver()));
                }
            });
        }
        else {
            return Promise.resolve(driver());
        }
    });
}
exports.install = install;
function isJreAvailable(log) {
    return __awaiter(this, void 0, void 0, function* () {
        const process = child_process.exec("java -version");
        return new Promise((resolve, reject) => {
            let result = "";
            process.stderr.on("data", data => {
                result += data.toString();
            });
            process.on("close", () => {
                resolve(!!result.match(/1\.8/));
            });
            process.on("error", err => {
                log(err.message, "ERROR");
                resolve(false);
            });
        });
    });
}
function reportAndCleanup(log) {
    return (error) => {
        log(error, "ERROR");
        fs.rmdir(exports.jreDir(), error => error
            ? log("Please manually delete " + exports.jreDir(), "ERROR")
            : log(exports.jreDir() + " deleted", "INFO"));
    };
}
function buildRequest(url) {
    return {
        url,
        rejectUnauthorized: false,
        headers: {
            connection: "keep-alive"
        }
    };
}
function progressBar(res) {
    const len = parseInt(res.headers["content-length"], 10);
    const bar = new ProgressBar("  downloading and preparing JRE [:bar] :percent :etas", {
        complete: "=",
        incomplete: " ",
        width: 80,
        total: len
    });
    res.on("data", (chunk) => bar.tick(chunk.length));
}
function driver() {
    let platform = os.platform();
    let driver;
    switch (platform) {
        case "darwin":
            driver = ["bin", "java"];
            break;
        case "win32":
            driver = ["bin", "javaw.exe"];
            break;
        case "linux":
            driver = ["bin", "java"];
            break;
        default:
            throw new Error("unsupported platform: " + platform);
    }
    var jreDirs = getDirectories(exports.jreDir());
    if (jreDirs.length < 1)
        throw new Error("no jre found in " + exports.jreDir());
    var d = driver.slice();
    d.unshift(jreDirs[0]);
    d.unshift(exports.jreDir());
    return path.join.apply(path, d);
}
exports.jreDir = () => path.join(os.homedir(), ".sonarjs", "jre");
function platform() {
    const platform = os.platform();
    let javaPlatform;
    switch (platform) {
        case "darwin":
            return "macosx";
        case "win32":
            return "win";
        case "linux":
            return "linux";
        default:
            throw new Error("unsupported platform: " + platform);
    }
}
exports.platform = platform;
function zip() {
    if (os.platform() === "win32") {
        return ".zip";
    }
    else {
        return ".tar.gz";
    }
}
function getDirectories(dirPath) {
    return fs
        .readdirSync(dirPath)
        .filter((file) => fs.statSync(path.join(dirPath, file)).isDirectory());
}
